diff -ruN proll_18.orig/Makefile proll-patch4/Makefile
--- proll_18.orig/Makefile	2002-09-13 14:16:59.000000000 +0000
+++ proll-patch4/Makefile	2004-11-13 15:50:49.000000000 +0000
@@ -4,6 +4,7 @@
 	make -C krups-ser    all
 	make -C espresso     all
 	make -C espresso-ser all
+	make -C qemu all
 
 clean:
 	make -C mrcoffee clean
@@ -11,3 +12,4 @@
 	make -C krups-ser    clean
 	make -C espresso     clean
 	make -C espresso-ser clean
+	make -C qemu clean
diff -ruN proll_18.orig/qemu/head.S proll-patch4/qemu/head.S
--- proll_18.orig/qemu/head.S	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch4/qemu/head.S	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,515 @@
+/**
+ ** Standalone startup code for Linux PROM emulator.
+ ** Copyright 1999 Pete A. Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+/*
+ * $Id: proll.patch,v 1.2 2004/12/19 23:18:01 bellard Exp $
+ */
+
+#include <psr.h>
+#include <asi.h>
+#include <crs.h>
+/* #include <asm/head.h> */	/* Trap entries. Do not use. */
+#include "phys_jj.h"
+
+#define C_LABEL(name)	name
+#define REGWIN_SZ   0x40
+
+#define WRITE_PAUSE    nop; nop; nop; /* Have to do this after %wim/%psr chg */
+
+  /* 22 is 24-2, (va)>>(SRMMU_PGDIR_SHIFT-PTESIZESHFT) */
+#define VATOPGDOFF(va) (((va)>>22)&0x3FC)
+#define VATOPMDOFF(va) (((va)>>16)&0xFC)
+
+#define NOP_INSN       0x01000000     /* Used to patch sparc_save_state */
+
+/* Here are some trap goodies */
+
+#if 0
+/* Generic trap entry. */
+#define TRAP_ENTRY(type, label) \
+	rd %psr, %l0; b label; rd %wim, %l3; nop;
+#endif
+
+/* Data/text faults. */
+#define SRMMU_TFAULT rd %psr, %l0; rd %wim, %l3; b C_LABEL(srmmu_fault); mov 1, %l7;
+#define SRMMU_DFAULT rd %psr, %l0; rd %wim, %l3; b C_LABEL(srmmu_fault); mov 0, %l7;
+
+#if 0
+/* This is for traps we should NEVER get. */
+#define BAD_TRAP(num) \
+        rd %psr, %l0; mov num, %l7; b bad_trap_handler; rd %wim, %l3;
+
+/* This is for traps when we want just skip the instruction which caused it */
+#define SKIP_TRAP(type, name) \
+	jmpl %l2, %g0; rett %l2 + 4; nop; nop;
+
+/* Notice that for the system calls we pull a trick.  We load up a
+ * different pointer to the system call vector table in %l7, but call
+ * the same generic system call low-level entry point.  The trap table
+ * entry sequences are also HyperSparc pipeline friendly ;-)
+ */
+
+/* Software trap for Linux system calls. */
+#define LINUX_SYSCALL_TRAP \
+        sethi %hi(C_LABEL(sys_call_table)), %l7; \
+        or %l7, %lo(C_LABEL(sys_call_table)), %l7; \
+        b linux_sparc_syscall; \
+        rd %psr, %l0;
+
+/* Software trap for SunOS4.1.x system calls. */
+#define SUNOS_SYSCALL_TRAP \
+        rd %psr, %l0; \
+        sethi %hi(C_LABEL(sunos_sys_table)), %l7; \
+        b linux_sparc_syscall; \
+        or %l7, %lo(C_LABEL(sunos_sys_table)), %l7;
+
+/* Software trap for Slowaris system calls. */
+#define SOLARIS_SYSCALL_TRAP \
+        b solaris_syscall; \
+        rd %psr, %l0; \
+        nop; \
+        nop;
+
+#define INDIRECT_SOLARIS_SYSCALL(x) \
+	mov x, %g1; \
+	b solaris_syscall; \
+	rd %psr, %l0; \
+	nop;
+
+#define BREAKPOINT_TRAP \
+	b breakpoint_trap; \
+	rd %psr,%l0; \
+	nop; \
+	nop;
+
+/* Software trap for Sparc-netbsd system calls. */
+#define NETBSD_SYSCALL_TRAP \
+        sethi %hi(C_LABEL(sys_call_table)), %l7; \
+        or %l7, %lo(C_LABEL(sys_call_table)), %l7; \
+        b bsd_syscall; \
+        rd %psr, %l0;
+
+/* The Get Condition Codes software trap for userland. */
+#define GETCC_TRAP \
+        b getcc_trap_handler; mov %psr, %l0; nop; nop;
+
+/* The Set Condition Codes software trap for userland. */
+#define SETCC_TRAP \
+        b setcc_trap_handler; mov %psr, %l0; nop; nop;
+
+/* This is for hard interrupts from level 1-14, 15 is non-maskable (nmi) and
+ * gets handled with another macro.
+ */
+#define TRAP_ENTRY_INTERRUPT(int_level) \
+        mov int_level, %l7; rd %psr, %l0; b real_irq_entry; rd %wim, %l3;
+
+/* NMI's (Non Maskable Interrupts) are special, you can't keep them
+ * from coming in, and basically if you get one, the shows over. ;(
+ * On the sun4c they are usually asynchronous memory errors, on the
+ * the sun4m they could be either due to mem errors or a software
+ * initiated interrupt from the prom/kern on an SMP box saying "I
+ * command you to do CPU tricks, read your mailbox for more info."
+ */
+#define NMI_TRAP \
+        rd %wim, %l3; b linux_trap_nmi_sun4c; mov %psr, %l0; nop;
+
+#endif
+
+/* Window overflows/underflows are special and we need to try to be as
+ * efficient as possible here....
+ */
+#define WINDOW_SPILL \
+        rd %psr, %l0; rd %wim, %l3; b spill_window_entry; nop;
+
+#define WINDOW_FILL \
+        rd %psr, %l0; rd %wim, %l3; b fill_window_entry; nop;
+
+#define STUB_TRAP	ba stub_trap; nop; nop; nop;
+
+#define TRAP_ENTRY(a,b)		STUB_TRAP
+#define SKIP_TRAP(a,b)		STUB_TRAP
+#define SUNOS_SYSCALL_TRAP	STUB_TRAP
+#define SOLARIS_SYSCALL_TRAP	STUB_TRAP
+#define NETBSD_SYSCALL_TRAP	STUB_TRAP
+#define LINUX_SYSCALL_TRAP	STUB_TRAP
+#define BREAKPOINT_TRAP		STUB_TRAP
+#define NMI_TRAP		STUB_TRAP
+#define GETCC_TRAP		STUB_TRAP
+#define SETCC_TRAP		STUB_TRAP
+#define BAD_TRAP(n)		STUB_TRAP
+#define	TRAP_ENTRY_INTERRUPT(i)		STUB_TRAP
+#define	INDIRECT_SOLARIS_SYSCALL(i)	STUB_TRAP
+
+	.section ".text"
+	.globl start, _start
+_start:
+start:
+	.globl spill_window_entry, fill_window_entry
+C_LABEL(trapbase):
+t_zero:	b goprol; nop; nop; nop;
+t_tflt:	SRMMU_TFAULT                        /* Inst. Access Exception        */
+t_bins:	TRAP_ENTRY(0x2, bad_instruction)    /* Illegal Instruction           */
+t_pins:	TRAP_ENTRY(0x3, priv_instruction)   /* Privileged Instruction        */
+t_fpd:	TRAP_ENTRY(0x4, fpd_trap_handler)   /* Floating Point Disabled       */
+t_wovf:	WINDOW_SPILL                        /* Window Overflow               */
+t_wunf:	WINDOW_FILL                         /* Window Underflow              */
+t_mna:	TRAP_ENTRY(0x7, mna_handler)        /* Memory Address Not Aligned    */
+t_fpe:	TRAP_ENTRY(0x8, fpe_trap_handler)   /* Floating Point Exception      */
+t_dflt:	SRMMU_DFAULT                        /* Data Miss Exception           */
+t_tio:	TRAP_ENTRY(0xa, do_tag_overflow)    /* Tagged Instruction Ovrflw     */
+t_wpt:	TRAP_ENTRY(0xb, do_watchpoint)      /* Watchpoint Detected           */
+t_badc:	BAD_TRAP(0xc) BAD_TRAP(0xd) BAD_TRAP(0xe) BAD_TRAP(0xf) BAD_TRAP(0x10)
+t_irq1:	TRAP_ENTRY_INTERRUPT(1)             /* IRQ Software/SBUS Level 1     */
+t_irq2:	TRAP_ENTRY_INTERRUPT(2)             /* IRQ SBUS Level 2              */
+t_irq3:	TRAP_ENTRY_INTERRUPT(3)             /* IRQ SCSI/DMA/SBUS Level 3     */
+t_irq4:	TRAP_ENTRY_INTERRUPT(4)             /* IRQ Software Level 4          */
+t_irq5:	TRAP_ENTRY_INTERRUPT(5)             /* IRQ SBUS/Ethernet Level 5     */
+t_irq6:	TRAP_ENTRY_INTERRUPT(6)             /* IRQ Software Level 6          */
+t_irq7:	TRAP_ENTRY_INTERRUPT(7)             /* IRQ Video/SBUS Level 5        */
+t_irq8:	TRAP_ENTRY_INTERRUPT(8)             /* IRQ SBUS Level 6              */
+t_irq9:	TRAP_ENTRY_INTERRUPT(9)             /* IRQ SBUS Level 7              */
+t_irq10:TRAP_ENTRY_INTERRUPT(10)            /* IRQ Timer #1 (one we use)     */
+t_irq11:TRAP_ENTRY_INTERRUPT(11)            /* IRQ Floppy Intr.              */
+t_irq12:TRAP_ENTRY_INTERRUPT(12)            /* IRQ Zilog serial chip         */
+t_irq13:TRAP_ENTRY_INTERRUPT(13)            /* IRQ Audio Intr.               */
+t_irq14:TRAP_ENTRY_INTERRUPT(14)            /* IRQ Timer #2                  */
+t_nmi:	NMI_TRAP                            /* Level 15 (NMI)                */
+t_racc:	TRAP_ENTRY(0x20, do_reg_access)     /* General Register Access Error */
+t_iacce:BAD_TRAP(0x21)                      /* Instr Access Error            */
+t_bad22:BAD_TRAP(0x22) BAD_TRAP(0x23)
+t_cpdis:TRAP_ENTRY(0x24, do_cp_disabled)    /* Co-Processor Disabled         */
+t_uflsh:SKIP_TRAP(0x25, unimp_flush)        /* Unimplemented FLUSH inst.     */
+t_bad26:BAD_TRAP(0x26) BAD_TRAP(0x27)
+t_cpexc:TRAP_ENTRY(0x28, do_cp_exception)   /* Co-Processor Exception        */
+t_dacce:SRMMU_DFAULT                        /* Data Access Error             */
+t_hwdz:	TRAP_ENTRY(0x2a, do_hw_divzero)     /* Division by zero, you lose... */
+t_dserr:BAD_TRAP(0x2b)                      /* Data Store Error              */
+t_daccm:BAD_TRAP(0x2c)                      /* Data Access MMU-Miss          */
+t_bad2d:               BAD_TRAP(0x2d) BAD_TRAP(0x2e) BAD_TRAP(0x2f)
+        BAD_TRAP(0x30) BAD_TRAP(0x31) BAD_TRAP(0x32) BAD_TRAP(0x33)
+        BAD_TRAP(0x34) BAD_TRAP(0x35) BAD_TRAP(0x36) BAD_TRAP(0x37)
+        BAD_TRAP(0x38) BAD_TRAP(0x39) BAD_TRAP(0x3a) BAD_TRAP(0x3b)
+t_iaccm:BAD_TRAP(0x3c)                      /* Instr Access MMU-Miss         */
+ BAD_TRAP(0x3d) BAD_TRAP(0x3e) BAD_TRAP(0x3f)
+ BAD_TRAP(0x40) BAD_TRAP(0x41) BAD_TRAP(0x42) BAD_TRAP(0x43)
+ BAD_TRAP(0x44) BAD_TRAP(0x45) BAD_TRAP(0x46) BAD_TRAP(0x47)
+ BAD_TRAP(0x48) BAD_TRAP(0x49) BAD_TRAP(0x4a) BAD_TRAP(0x4b)
+ BAD_TRAP(0x4c) BAD_TRAP(0x4d) BAD_TRAP(0x4e) BAD_TRAP(0x4f)
+ BAD_TRAP(0x50) BAD_TRAP(0x51) BAD_TRAP(0x52) BAD_TRAP(0x53)
+ BAD_TRAP(0x54) BAD_TRAP(0x55) BAD_TRAP(0x56) BAD_TRAP(0x57)
+ BAD_TRAP(0x58) BAD_TRAP(0x59) BAD_TRAP(0x5a) BAD_TRAP(0x5b)
+ BAD_TRAP(0x5c) BAD_TRAP(0x5d) BAD_TRAP(0x5e) BAD_TRAP(0x5f)
+ BAD_TRAP(0x60) BAD_TRAP(0x61) BAD_TRAP(0x62) BAD_TRAP(0x63)
+ BAD_TRAP(0x64) BAD_TRAP(0x65) BAD_TRAP(0x66) BAD_TRAP(0x67)
+ BAD_TRAP(0x68) BAD_TRAP(0x69) BAD_TRAP(0x6a) BAD_TRAP(0x6b)
+ BAD_TRAP(0x6c) BAD_TRAP(0x6d) BAD_TRAP(0x6e) BAD_TRAP(0x6f)
+ BAD_TRAP(0x70) BAD_TRAP(0x71) BAD_TRAP(0x72) BAD_TRAP(0x73)
+ BAD_TRAP(0x74) BAD_TRAP(0x75) BAD_TRAP(0x76) BAD_TRAP(0x77)
+ BAD_TRAP(0x78) BAD_TRAP(0x79) BAD_TRAP(0x7a) BAD_TRAP(0x7b)
+ BAD_TRAP(0x7c) BAD_TRAP(0x7d) BAD_TRAP(0x7e) BAD_TRAP(0x7f)
+t_sunos:SUNOS_SYSCALL_TRAP                  /* SunOS System Call             */
+t_sbkpt:BREAKPOINT_TRAP                     /* Software Breakpoint/KGDB      */
+t_divz:	BAD_TRAP(0x82)                      /* Divide by zero trap           */
+t_flwin:TRAP_ENTRY(0x83, do_flush_windows)  /* Flush Windows Trap            */
+t_clwin:BAD_TRAP(0x84)                      /* Clean Windows Trap            */
+t_rchk:	BAD_TRAP(0x85)                      /* Range Check                   */
+t_funal:BAD_TRAP(0x86)                      /* Fix Unaligned Access Trap     */
+t_iovf:	BAD_TRAP(0x87)                      /* Integer Overflow Trap         */
+t_slowl:SOLARIS_SYSCALL_TRAP                /* Slowaris System Call          */
+t_netbs:NETBSD_SYSCALL_TRAP                 /* Net-B.S. System Call          */
+t_bad8a:BAD_TRAP(0x8a) BAD_TRAP(0x8b) BAD_TRAP(0x8c) BAD_TRAP(0x8d)
+ BAD_TRAP(0x8e) BAD_TRAP(0x8f)
+t_linux:LINUX_SYSCALL_TRAP                  /* Linux System Call             */
+t_bad91:BAD_TRAP(0x91) BAD_TRAP(0x92) BAD_TRAP(0x93)
+ BAD_TRAP(0x94) BAD_TRAP(0x95) BAD_TRAP(0x96) BAD_TRAP(0x97)
+ BAD_TRAP(0x98) BAD_TRAP(0x99) BAD_TRAP(0x9a) BAD_TRAP(0x9b) BAD_TRAP(0x9c) BAD_TRAP(0x9d) BAD_TRAP(0x9e) BAD_TRAP(0x9f)
+t_getcc:GETCC_TRAP                          /* Get Condition Codes           */
+t_setcc:SETCC_TRAP                          /* Set Condition Codes           */
+t_bada2:BAD_TRAP(0xa2) BAD_TRAP(0xa3)
+ BAD_TRAP(0xa4) BAD_TRAP(0xa5) BAD_TRAP(0xa6)
+t_slowi:INDIRECT_SOLARIS_SYSCALL(156)
+ BAD_TRAP(0xa8) BAD_TRAP(0xa9) BAD_TRAP(0xaa) BAD_TRAP(0xab)
+ BAD_TRAP(0xac) BAD_TRAP(0xad) BAD_TRAP(0xae) BAD_TRAP(0xaf)
+ BAD_TRAP(0xb0) BAD_TRAP(0xb1) BAD_TRAP(0xb2) BAD_TRAP(0xb3)
+ BAD_TRAP(0xb4) BAD_TRAP(0xb5) BAD_TRAP(0xb6) BAD_TRAP(0xb7)
+ BAD_TRAP(0xb8) BAD_TRAP(0xb9) BAD_TRAP(0xba) BAD_TRAP(0xbb)
+ BAD_TRAP(0xbc) BAD_TRAP(0xbd) BAD_TRAP(0xbe) BAD_TRAP(0xbf)
+t_badc0:BAD_TRAP(0xc0) BAD_TRAP(0xc1) BAD_TRAP(0xc2) BAD_TRAP(0xc3)
+ BAD_TRAP(0xc4) BAD_TRAP(0xc5) BAD_TRAP(0xc6) BAD_TRAP(0xc7)
+ BAD_TRAP(0xc8) BAD_TRAP(0xc9) BAD_TRAP(0xca) BAD_TRAP(0xcb)
+ BAD_TRAP(0xcc) BAD_TRAP(0xcd) BAD_TRAP(0xce) BAD_TRAP(0xcf)
+ BAD_TRAP(0xd0) BAD_TRAP(0xd1) BAD_TRAP(0xd2) BAD_TRAP(0xd3)
+t_badd4:BAD_TRAP(0xd4) BAD_TRAP(0xd5) BAD_TRAP(0xd6) BAD_TRAP(0xd7)
+ BAD_TRAP(0xd8) BAD_TRAP(0xd9) BAD_TRAP(0xda) BAD_TRAP(0xdb)
+ BAD_TRAP(0xdc) BAD_TRAP(0xdd) BAD_TRAP(0xde) BAD_TRAP(0xdf)
+ BAD_TRAP(0xe0) BAD_TRAP(0xe1) BAD_TRAP(0xe2) BAD_TRAP(0xe3)
+ BAD_TRAP(0xe4) BAD_TRAP(0xe5) BAD_TRAP(0xe6) BAD_TRAP(0xe7)
+t_bade8:BAD_TRAP(0xe8) BAD_TRAP(0xe9) BAD_TRAP(0xea) BAD_TRAP(0xeb)
+ BAD_TRAP(0xec) BAD_TRAP(0xed) BAD_TRAP(0xee) BAD_TRAP(0xef)
+ BAD_TRAP(0xf0) BAD_TRAP(0xf1) BAD_TRAP(0xf2) BAD_TRAP(0xf3)
+ BAD_TRAP(0xf4) BAD_TRAP(0xf5) BAD_TRAP(0xf6) BAD_TRAP(0xf7)
+ BAD_TRAP(0xf8) BAD_TRAP(0xf9) BAD_TRAP(0xfa) BAD_TRAP(0xfb)
+t_badfc:BAD_TRAP(0xfc) BAD_TRAP(0xfd)
+dbtrap:	BAD_TRAP(0xfe)                      /* Debugger/PROM breakpoint #1   */
+dbtrap2:BAD_TRAP(0xff)                      /* Debugger/PROM breakpoint #2   */	
+
+stub_trap:
+   set (PHYS_JJ_TCX_FB + 0xbf0), %g5	/* 2 cells from side */
+   set 0x00ffffff, %g4
+   sta %g4, [%g5] ASI_M_BYPASS
+1:	ba 1b; nop
+
+	.section ".bss"
+	.align 8
+bss_start:
+	.align	0x1000		! PAGE_SIZE
+	.globl C_LABEL(bootup_user_stack)
+        .type   bootup_user_stack,#object
+        .size   bootup_user_stack,0x2000
+C_LABEL(bootup_user_stack):		.skip 0x2000
+
+	.section ".text"
+
+goprol:
+	! %g1 contains end of memory
+	! map PROLDATA to PROLBASE+PROLSIZE to end of ram
+	set	PROLSIZE+0x1000-PROLDATA+PROLBASE, %g2	! add 0x1000 for temp tables
+	sub	%g1, %g2, %g2			! start of private memory
+	srl	%g2, 0x4, %g7			! ctx table at s+0x0
+	add	%g2, 0x400, %g3			! l1 table at s+0x400
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x400, %g2			! s+0x400
+	add	%g2, 0x800, %g3			! l2 table for ram (00xxxxxx) at s+0x800
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x500, %g3			! l2 table for rom (ffxxxxxx) at s+0x900
+	add	%g2, 0x3fc, %g2			! s+0x7fc
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x4, %g2			! s+0x800
+	set	((7 << 2) | 2), %g3		! 7 = U: --- S: RWX (main memory)
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x200, %g3			! l3 table for rom at s+0xa00
+	add	%g2, 0x1d0, %g2			! s+0x9d0
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x30, %g2			! s+0xa00
+
+	set	PROLBASE, %g3
+	set	0x1000, %g5
+	set	(PROLDATA-PROLBASE)/0x1000, %g6 ! # of .text pages
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((7 << 2) | 2), %g4	! 4 = U: --X S: --X (rom, execute only)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+#if 0	
+	set	(PROLDATA-PROLRODATA)/0x1000, %g6 ! # of .rodata pages
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((0 << 2) | 2), %g4	! 0 = U: R-- S: R-- (rom, read only)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+#endif
+	set	(PROLBASE+PROLSIZE-PROLDATA)/0x1000, %g6 ! # of .bss pages
+	set	0x1000, %g4
+	sll	%g7, 0x4, %g3
+	add	%g4, %g3, %g3
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((7 << 2) | 2), %g4        ! 5 = U: R-- S: RW- (data area, read/write)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+
+	mov	%g1, %g3
+
+	set     AC_M_CTPR, %g2
+	sta     %g7, [%g2] ASI_M_MMUREGS	! set ctx table ptr
+	set	1, %g1
+	sta     %g1, [%g0] ASI_M_MMUREGS	! enable mmu
+
+	/*
+	 * The code which enables traps is a simplified version of
+	 * kernel head.S.
+	 *
+	 * We know number of windows as 8 so we do not calculate them.
+	 * The deadwood is here for any case.
+	 */
+
+	/* Turn on Supervisor, EnableFloating, and all the PIL bits.
+	 * Also puts us in register window zero with traps off.
+	 */
+	set	(PSR_PS | PSR_S | PSR_PIL | PSR_EF), %g2
+	wr	%g2, 0x0, %psr
+	WRITE_PAUSE
+
+	/* I want a kernel stack NOW! */
+	set	C_LABEL(bootup_user_stack), %g1
+	set	(0x2000 - REGWIN_SZ), %g2
+	add	%g1, %g2, %sp
+	mov	0, %fp			/* And for good luck */
+
+	/* Zero out our BSS section. */
+	set	C_LABEL(bss_start) , %o0	! First address of BSS
+	set	C_LABEL(end) , %o1		! Last address of BSS
+	ba	2f
+	 nop
+1:
+	st	%g0, [%o0]
+2:
+	subcc	%o0, %o1, %g0
+	bl	1b
+	 add	%o0, 0x4, %o0
+
+	sethi	%hi( C_LABEL(ram_size) ), %o0
+	st	%g3, [%o0 + %lo( C_LABEL(ram_size) )]
+
+	mov	2, %g1
+	wr	%g1, 0x0, %wim			! make window 1 invalid
+	WRITE_PAUSE
+
+#if 0
+	wr  %g0, 0x0, %wim
+	WRITE_PAUSE
+	save
+	rd  %psr, %g3
+	restore
+	and  %g3, PSR_CWP, %g3
+	add  %g3, 0x1, %g3
+#else
+	or	%g0, 8, %g3
+#endif
+
+#if 0
+	sethi	%hi( C_LABEL(cputyp) ), %o0
+	st	%g7, [%o0 + %lo( C_LABEL(cputyp) )]
+
+	sethi	%hi( C_LABEL(nwindows) ), %g4
+	st	%g3, [%g4 + %lo( C_LABEL(nwindows) )]
+
+	sub	%g3, 0x1, %g3
+	sethi	%hi( C_LABEL(nwindowsm1) ), %g4
+	st	%g3, [%g4 + %lo( C_LABEL(nwindowsm1) )]
+#endif
+
+	/* Here we go, start using Linux's trap table... */
+	set	C_LABEL(trapbase), %g3
+	wr	%g3, 0x0, %tbr
+	WRITE_PAUSE
+
+	/* Finally, turn on traps so that we can call c-code. */
+	rd	%psr, %g3
+	wr	%g3, 0x0, %psr
+	WRITE_PAUSE
+
+	wr	%g3, PSR_ET, %psr
+	WRITE_PAUSE
+
+	.globl prolmain
+	call C_LABEL(prolmain)
+	 nop
+
+3:
+	b       3b
+	 nop
+
+/*
+ * Memory access trap handler
+ *   %l0  program %psr from trap table entry
+ *   %l1  program %pc from hardware
+ *   %l2  program %npc from hardware
+ *   %l3  program %wim from trap table entry
+ *   %l4
+ *   %l5
+ *   %l6
+ *   %l7  text flag from trap table entry
+ */
+
+	.section ".text"
+	.globl srmmu_fault
+C_LABEL(srmmu_fault):
+
+	set AC_M_SFAR, %l6
+	set AC_M_SFSR, %l5
+	lda [%l6] ASI_M_MMUREGS, %l6
+	lda [%l5] ASI_M_MMUREGS, %l5
+
+	set ignore_fault, %l5
+	ld [%l5], %l5
+	subcc %l5, %g0, %g0		/* NULL pointer trap faults always */
+	be 3f
+	 nop
+	subcc %l5, %l6, %g0
+	be 2f
+	 nop
+3:
+
+   set (PHYS_JJ_TCX_FB + 0xbf0), %g5	/* 2 cells from side */
+   set 0x00ffffff, %g4
+   sta %g4, [%g5] ASI_M_BYPASS
+   add %g5, 8, %g5			/* On right side */
+   sta %g4, [%g5] ASI_M_BYPASS
+1:	ba 1b; nop
+
+2:
+	set C_LABEL(fault_ignored), %l5
+	mov 1, %l6
+	st %l6, [%l5]
+
+	/*
+	 * Skip the faulting instruction.
+	 * I think it works when next instruction is a branch even.
+	 */
+	or %l2, 0, %l1
+	add %l2, 4, %l2
+
+	wr %l0, 0, %psr
+	WRITE_PAUSE
+	jmp %l1
+	rett %l2
+
+/*
+ * Slow external versions of st_bypass and ld_bypass.
+ * rconsole.c uses inlines. We call these in places which are not speed
+ * critical, to avoid compiler bugs.
+ */
+	.globl C_LABEL(st_bypass)
+C_LABEL(st_bypass):
+	retl
+	 sta %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ld_bypass)
+C_LABEL(ld_bypass):
+	retl
+	 lda [%o0] ASI_M_BYPASS, %o0
+	.globl C_LABEL(sth_bypass)
+C_LABEL(sth_bypass):
+	retl
+	 stha %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ldh_bypass)
+C_LABEL(ldh_bypass):
+	retl
+	 lduha [%o0] ASI_M_BYPASS, %o0
+	.globl C_LABEL(stb_bypass)
+C_LABEL(stb_bypass):
+	retl
+	 stba %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ldb_bypass)
+C_LABEL(ldb_bypass):
+	retl
+	 lduba [%o0] ASI_M_BYPASS, %o0
diff -ruN proll_18.orig/qemu/main.c proll-patch4/qemu/main.c
--- proll_18.orig/qemu/main.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch4/qemu/main.c	2004-11-23 19:05:34.000000000 +0000
@@ -0,0 +1,178 @@
+/**
+ ** Proll (PROM replacement)
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+#include <stdarg.h>
+
+// #include <asm/contregs.h>
+#include <asi.h>
+#include "pgtsrmmu.h"
+#include "iommu.h"		/* Typical SBus IOMMU for sun4m */
+#include "phys_jj.h"
+#include "vconsole.h"
+#include "version.h"
+#include <general.h>		/* __P() */
+#include <net.h>		/* init_net() */
+#include <romlib.h>		/* we are a provider for part of this. */
+#include <netpriv.h>		/* myipaddr */
+#include <arpa.h>
+#include <system.h>		/* our own prototypes */
+
+static void init_idprom(void);
+static void makepages_q(struct phym *t, unsigned int highbase);
+
+struct vconterm dp0;
+struct mem cmem;		/* Current memory, virtual */
+struct mem cio;			/* Current I/O space */
+struct phym pmem;		/* Current phys. mem. */
+struct iommu ciommu;		/* Our IOMMU on sun4m */
+
+static char *hw_idprom;
+int ignore_fault, fault_ignored, ram_size;
+
+/*
+ */
+void prolmain()
+{
+	//static const char fname[14] = "00000000.PROL";
+	static struct banks bb;
+	unsigned int hiphybas;
+	const void *romvec;
+
+	vcon_init(&dp0, PHYS_JJ_TCX_FB);
+	printk("PROLL %s QEMU\n", PROLL_VERSION_STRING);
+	printk("%d MB total\n", ram_size/(1024*1024));
+
+	bb.nbanks = 1;
+	bb.bankv[0].start = 0;
+	bb.bankv[0].length = ram_size;
+
+	hiphybas = ram_size - PROLSIZE;
+
+	mem_init(&cmem, (char *) &_end, (char *)(PROLBASE+PROLSIZE));
+	makepages_q(&pmem, hiphybas);
+	init_mmu_swift((unsigned int)pmem.pctp - PROLBASE + hiphybas);
+
+	mem_init(&cio, (char *)(PROLBASE+PROLSIZE),
+	    (char *)(PROLBASE+PROLSIZE+IOMAPSIZE));
+
+	iommu_init(&ciommu, hiphybas);
+
+	/*
+	 */
+	init_idprom();
+	sched_init();
+	le_probe();
+	init_net();
+
+#if 0
+#if 0 /* RARP */
+	if (rarp() != 0) fatal();
+	/* printrarp(); */
+	xtoa(myipaddr, fname, 8);
+	if (load(servaddr, fname) != 0) fatal();
+#else
+	if (bootp() != 0) fatal();
+	/*
+	 * boot_rec.bp_file cannot be used because system PROM
+	 * uses it to locate ourselves. If we load from boot_rec.bp_file,
+	 * we will loop reloading PROLL over and over again.
+	 * Thus we use traditional PROLL scheme HEXIPADDR.PROL (single L).
+	 */
+	xtoa(myipaddr, fname, 8);
+	if (load(boot_rec.bp_siaddr, fname) != 0) fatal();
+#endif
+#endif
+
+	romvec = init_openprom(bb.nbanks, bb.bankv, hiphybas);
+
+	printk("Memory used: virt 0x%x:0x%x[%dK] iomap 0x%x:0x%x\n",
+	    PROLBASE, (int)cmem.curp, ((unsigned) cmem.curp - PROLBASE)/1024,
+	    (int)cio.start, (int)cio.curp);
+	//set_timeout(5);  while (!chk_timeout()) { }  /* P3: let me read */
+
+	{
+	        void (*entry)(const void *, int, int, int, int) = (void (*)(const void*, int, int, int, int)) LOADBASE;
+		entry(romvec, 0, 0, 0, 0);
+	}
+
+	mem_fini(&cmem);
+	vcon_fini(&dp0);
+}
+
+/*
+ * dvma_alloc over iommu_alloc.
+ */
+void *dvma_alloc(int size, unsigned int *pphys)
+{
+	return iommu_alloc(&ciommu, size, pphys);
+}
+
+/*
+ */
+void udelay(unsigned long usecs)
+{
+	int i, n;
+	n = usecs*50;
+	for (i = 0; i < n; i++) { }
+}
+
+static void init_idprom()
+{
+	char *va_prom;
+
+	if ((va_prom = map_io(PHYS_JJ_EEPROM, PHYS_JJ_EEPROM_SIZE)) == NULL) {
+		printk("init_idprom: cannot map eeprom\n");
+		fatal();
+	}
+	bcopy(va_prom + PHYS_JJ_IDPROM_OFF, idprom, IDPROM_SIZE);
+	/*
+	 * hw_idprom is not used anywhere.
+	 * It's just as we hate to leave hanging pointers (I/O page here).
+	 */
+	hw_idprom = va_prom; 
+}
+
+/*
+ * Make CPU page tables.
+ * Returns pointer to context table.
+ * Here we ignore memory allocation errors which "should not happen"
+ * because we cannot print anything anyways if memory initialization fails.
+ */
+void makepages_q(struct phym *t, unsigned int highbase)
+{
+	unsigned int *ctp, *l1, pte;
+	int i;
+	unsigned int pa, va;
+
+	ctp = mem_zalloc(&cmem, NCTX_SWIFT*sizeof(int), NCTX_SWIFT*sizeof(int));
+	l1 = mem_zalloc(&cmem, 256*sizeof(int), 256*sizeof(int));
+
+	pte = SRMMU_ET_PTD | (((unsigned int)l1 - PROLBASE + highbase) >> 4);
+	for (i = 0; i < NCTX_SWIFT; i++) {
+		ctp[i] = pte;
+	}
+
+	pa = PROLBASE;
+	for (va = PROLBASE; va < PROLDATA; va += PAGE_SIZE) {
+	        map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+	pa = highbase + PROLDATA - PROLBASE;
+	for (va = PROLDATA; va < PROLBASE + PROLSIZE; va += PAGE_SIZE) {
+		map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+
+	/* We need to start from LOADBASE, but kernel wants PAGE_SIZE. */
+	pa = 0;
+	for (va = 0; va < LOWMEMSZ; va += PAGE_SIZE) {
+		map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+
+	t->pctp = ctp;
+	t->pl1 = l1;
+	t->pbas = highbase;
+}
diff -ruN proll_18.orig/qemu/Makefile proll-patch4/qemu/Makefile
--- proll_18.orig/qemu/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch4/qemu/Makefile	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,119 @@
+#
+# proll:
+# qemu/Makefile - make PROLL for QEMU
+# $Id: proll.patch,v 1.2 2004/12/19 23:18:01 bellard Exp $
+#
+# Copyright 1999 Pete Zaitcev
+# This is Free Software is licensed under terms of GNU General Public License.
+#
+
+CC = gcc
+
+#CROSS = /usr/local/sparc/bin/sparc-sun-linux-
+CROSS = sparc-unknown-linux-gnu-
+
+CROSSCC = $(CROSS)gcc
+CROSSLD = $(CROSS)ld
+CROSSNM = $(CROSS)nm
+
+RM = /bin/rm -f
+ELFTOAOUT = elftoaout
+
+#
+SRC = ../src
+
+# Due to remapping algorithm PROLBASE should be algned on PMD.
+# We make PROLBASE a define instead of using _start because we
+# want to shift it to form a PGD entry. A relocatable label will not work.
+# Linux kernel expects us to be at LINUX_OPPROM_BEGVM <asm-sparc/openprom.h>.
+PROLBASE =   0xffd00000
+PROLRODATA = 0xffd07000
+PROLDATA =   0xffd09000
+PROLSIZE = (240*1024)
+
+# Linux
+# Fixed %g6 is for arch/sparc/kernel/head.S, it seems ok w/o -ffixed-g6.
+# Kernel uses -fcall-used-g5 -fcall-used-g7, we probably do not need them.
+# __ANSI__ is supposed to be on by default but it is not.
+CFLAGS = -O2 -Wall -DPROLBASE=$(PROLBASE) -DPROLDATA=$(PROLDATA) -DPROLRODATA=$(PROLRODATA) -D__ANSI__=1 -I$(SRC) -mcpu=hypersparc -g
+ASFLAGS = -D__ASSEMBLY__ -I$(SRC) -DPROLRODATA=$(PROLRODATA) -DPROLDATA=$(PROLDATA) -DPROLSIZE=$(PROLSIZE) -g
+# Solaris or Linux/i386 cross compilation
+#CFLAGS = -Iinclude -O
+
+LDFLAGS = -N -Ttext $(PROLBASE) --section-start .rodata=$(PROLRODATA) -Tdata $(PROLDATA) -Tbss $(PROLDATA)
+
+ALL = proll.aout
+PROLLEXE = proll.elf
+
+OBJS = head.o wuf.o wof.o main.o vconsole.o hconsole.o rconsole.o \
+ printf.o le.o system.o iommu.o \
+ arp.o netinit.o bootp.o packet.o tftp.o udp.o sched_4m.o openprom.o
+
+all:           $(ALL)
+
+$(PROLLEXE):   $(OBJS)
+	$(CROSSLD) $(LDFLAGS) -o $(PROLLEXE) $(OBJS)
+
+head.o:         head.S $(SRC)/phys_jj.h \
+  $(SRC)/asi.h $(SRC)/psr.h $(SRC)/crs.h
+	$(CROSSCC) $(ASFLAGS) -DPROLBASE=$(PROLBASE) -o $*.o -c $*.S
+
+main.o:         main.c $(SRC)/asi.h $(SRC)/pgtsrmmu.h $(SRC)/iommu.h \
+  $(SRC)/phys_jj.h $(SRC)/vconsole.h $(SRC)/version.h $(SRC)/general.h \
+  $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arpa.h $(SRC)/system.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+openprom.o:	openprom.c $(SRC)/openprom.h $(SRC)/general.h $(SRC)/romlib.h \
+  $(SRC)/vconsole.h $(SRC)/system.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+
+system.o:       $(SRC)/system.c $(SRC)/vconsole.h $(SRC)/pgtsrmmu.h \
+  $(SRC)/timer.h $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/asi.h \
+  $(SRC)/netpriv.h $(SRC)/arpa.h $(SRC)/system.h $(SRC)/crs.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+iommu.o:        $(SRC)/iommu.c $(SRC)/pgtsrmmu.h $(SRC)/phys_jj.h $(SRC)/iommu.h \
+ $(SRC)/vconsole.h $(SRC)/general.h $(SRC)/romlib.h $(SRC)/system.h $(SRC)/asi.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+vconsole.o:	$(SRC)/vconsole.c $(SRC)/vconsole.h $(SRC)/hconsole.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+hconsole.o:	$(SRC)/hconsole.c $(SRC)/hconsole.h $(SRC)/rconsole.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+rconsole.o:	$(SRC)/rconsole.c $(SRC)/rconsole.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+printf.o:       $(SRC)/printf.c
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+le.o:		$(SRC)/le.c $(SRC)/dma.h $(SRC)/system.h $(SRC)/netpriv.h $(SRC)/romlib.h $(SRC)/general.h $(SRC)/net.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+
+arp.o:		$(SRC)/arp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+netinit.o:	$(SRC)/netinit.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h $(SRC)/ip.h $(SRC)/udp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+tftp.o:		$(SRC)/tftp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/arpa.h $(SRC)/romlib.h $(SRC)/tftp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+udp.o:		$(SRC)/udp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h $(SRC)/ip.h $(SRC)/udp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+packet.o:	$(SRC)/packet.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+sched_4m.o:	$(SRC)/sched_4m.c $(SRC)/system.h $(SRC)/general.h $(SRC)/romlib.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+bootp.o:	$(SRC)/bootp.c $(SRC)/general.h $(SRC)/net.h \
+  $(SRC)/arpa.h $(SRC)/romlib.h $(SRC)/system.h $(SRC)/bootp.h
+	$(CROSSCC) $(CFLAGS) -DNOBPEXT=1 -c $(SRC)/$*.c
+
+wuf.o:		$(SRC)/wuf.S
+	$(CROSSCC) $(ASFLAGS) -o $*.o -c $(SRC)/$*.S
+wof.o:		$(SRC)/wof.S
+	$(CROSSCC) $(ASFLAGS) -o $*.o -c $(SRC)/$*.S
+
+#genlab.o:      genlab.c
+#	$(CC) -c $*.c
+#
+#genlab:        genlab.o
+#	$(CC) -o genlab genlab.o
+
+clean:
+	$(RM) $(OBJS)
+	$(RM) $(PROLLEXE) proll.aout
+
+proll.aout:	$(PROLLEXE)
+	$(ELFTOAOUT) -o proll.aout $(PROLLEXE)
diff -ruN proll_18.orig/qemu/openprom.c proll-patch4/qemu/openprom.c
--- proll_18.orig/qemu/openprom.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch4/qemu/openprom.c	2004-11-23 19:14:05.000000000 +0000
@@ -0,0 +1,596 @@
+/*
+ * PROM interface support
+ * Copyright 1996 The Australian National University.
+ * Copyright 1996 Fujitsu Laboratories Limited
+ * Copyright 1999 Pete A. Zaitcev
+ * This software may be distributed under the terms of the Gnu
+ * Public License version 2 or later
+ */
+
+#include <openprom.h>
+#include <general.h>
+#include <romlib.h>
+#include <system.h>
+#include <vconsole.h>
+#include "phys_jj.h"
+
+struct property {
+	const char *name;
+	const char *value;
+	const int length;
+};
+
+struct node {
+	const struct property *properties;
+	/* short */ const int sibling;
+	/* short */ const int child;
+};
+
+static int obp_nextnode(int node);
+static int obp_child(int node);
+static int obp_proplen(int node, char *name);
+static int obp_getprop(int node, char *name, char *val);
+static int obp_setprop(int node, char *name, char *val, int len);
+static const char *obp_nextprop(int node, char *name);
+
+static char obp_idprom[IDPROM_SIZE];
+static const struct property null_properties = { NULL, NULL, -1 };
+static const int prop_true = -1;
+
+static const struct property propv_root[] = {
+	{"name",	"SUNW,JavaStation-1", sizeof("SUNW,JavaStation-1") },
+	{"idprom",	obp_idprom, IDPROM_SIZE},
+	{"banner-name", "JavaStation", sizeof("JavaStation")},
+	{"compatible",	"sun4m", 6},
+	{NULL, NULL, -1}
+};
+
+static const int prop_iommu_reg[] = {
+	0x0, 0x10000000, 0x00000300,
+};
+static const struct property propv_iommu[] = {
+	{"name",	"iommu", sizeof("iommu")},
+	{"reg",		(char*)&prop_iommu_reg[0], sizeof(prop_iommu_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_sbus_ranges[] = {
+	0x0, 0x0, 0x0, 0x30000000, 0x10000000,
+	0x1, 0x0, 0x0, 0x40000000, 0x10000000,
+	0x2, 0x0, 0x0, 0x50000000, 0x10000000,
+	0x3, 0x0, 0x0, 0x60000000, 0x10000000,
+	0x4, 0x0, 0x0, 0x70000000, 0x10000000,
+};
+static const struct property propv_sbus[] = {
+	{"name",	"sbus", 5},
+	{"ranges",	(char*)&prop_sbus_ranges[0], sizeof(prop_sbus_ranges)},
+	{NULL, NULL, -1}
+};
+
+static const int prop_tcx_regs[] = {
+	0x2, 0x00800000, 0x00100000,
+	0x2, 0x02000000, 0x00000001,
+	0x2, 0x04000000, 0x00800000,
+	0x2, 0x06000000, 0x00800000,
+	0x2, 0x0a000000, 0x00000001,
+	0x2, 0x0c000000, 0x00000001,
+	0x2, 0x0e000000, 0x00000001,
+	0x2, 0x00700000, 0x00001000,
+	0x2, 0x00200000, 0x00000004,
+	0x2, 0x00300000, 0x0000081c,
+	0x2, 0x00000000, 0x00010000,
+	0x2, 0x00240000, 0x00000004,
+	0x2, 0x00280000, 0x00000001,
+};
+
+#if 1	/* Zaitcev */
+static const int pixfreq = 0x03dfd240;
+static const int hbporch = 0xa0;
+static const int vfreq = 0x3c;
+#endif
+#if 0	/* Kevin Boone - 70Hz refresh */
+static const int pixfreq = 0x047868C0;
+static const int hbporch = 0x90;
+static const int vfreq = 0x46;
+#endif
+
+static const int vbporch = 0x1d;
+static const int vsync = 0x6;
+static const int hsync = 0x88;
+static const int vfporch = 0x3;
+static const int hfporch = 0x18;
+static const int height = 0x300;
+static const int width = 0x400;
+static const int linebytes = 0x400;
+static const int depth = 8;
+static const int tcx_intr[] = { 5, 0 };
+static const int tcx_interrupts = 5;
+static const struct property propv_sbus_tcx[] = {
+	{"name",	"SUNW,tcx", sizeof("SUNW,tcx")},
+	{"vbporch",	(char*)&vbporch, sizeof(int)},
+	{"hbporch",	(char*)&hbporch, sizeof(int)},
+	{"vsync",	(char*)&vsync, sizeof(int)},
+	{"hsync",	(char*)&hsync, sizeof(int)},
+	{"vfporch",	(char*)&vfporch, sizeof(int)},
+	{"hfporch",	(char*)&hfporch, sizeof(int)},
+	{"pixfreq",	(char*)&pixfreq, sizeof(int)},
+	{"vfreq",	(char*)&vfreq, sizeof(int)},
+	{"height",	(char*)&height, sizeof(int)},
+	{"width",	(char*)&width, sizeof(int)},
+	{"linebytes",	(char*)&linebytes, sizeof(int)},
+	{"depth",	(char*)&depth, sizeof(int)},
+	{"reg",		(char*)&prop_tcx_regs[0], sizeof(prop_tcx_regs)},
+	{"tcx-8-bit",	(char*)&prop_true, 0},
+	{"intr",	(char*)&tcx_intr[0], sizeof(tcx_intr)},
+	{"interrupts",	(char*)&tcx_interrupts, sizeof(tcx_interrupts)},
+	{"device_type",	"display", sizeof("display")},
+	{NULL, NULL, -1}
+};
+
+static const int prop_cs4231_reg[] = {
+	0x3, 0x0C000000, 0x00000040
+};
+static const int cs4231_interrupts = 5;
+static const int cs4231_intr[] = { 5, 0 };
+
+static const struct property propv_sbus_cs4231[] = {
+	{"name",	"SUNW,CS4231", sizeof("SUNW,CS4231") },
+	{"intr",	(char*)&cs4231_intr[0], sizeof(cs4231_intr) },
+	{"interrupts",  (char*)&cs4231_interrupts, sizeof(cs4231_interrupts) },	
+	{"reg",		(char*)&prop_cs4231_reg[0], sizeof(prop_cs4231_reg) },
+	{"device_type", "serial", sizeof("serial") },
+	{"alias",	"audio", sizeof("audio") },
+	{NULL, NULL, -1}
+};
+
+static const int cpu_nctx = NCTX_SWIFT;
+static const int cpu_cache_line_size = 0x20;
+static const int cpu_cache_nlines = 0x200;
+static const struct property propv_cpu[] = {
+	{"name",	"STP1012PGA", sizeof("STP1012PGA") },
+	{"device_type",	"cpu", 4 },
+	{"mmu-nctx",	(char*)&cpu_nctx, sizeof(int)},
+	{"cache-line-size",	(char*)&cpu_cache_line_size, sizeof(int)},
+	{"cache-nlines",	(char*)&cpu_cache_nlines, sizeof(int)},
+	{NULL, NULL, -1}
+};
+
+static const int prop_obio_ranges[] = {
+	0x0, 0x0, 0x0, 0x71000000, 0x01000000,
+};
+static const struct property propv_obio[] = {
+	{"name",	"obio", 5 },
+	{"ranges",	(char*)&prop_obio_ranges[0], sizeof(prop_obio_ranges) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_auxio_reg[] = {
+	0x0, 0x00900000, 0x00000001,
+};
+static const struct property propv_obio_auxio[] = {
+	{"name",	"auxio", sizeof("auxio") },
+	{"reg",		(char*)&prop_auxio_reg[0], sizeof(prop_auxio_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_int_reg[] = {
+	0x0, 0x00e00000, 0x00000010,
+	0x0, 0x00e10000, 0x00000010,
+};
+static const struct property propv_obio_int[] = {
+	{"name",	"interrupt", sizeof("interrupt")},
+	{"reg",		(char*)&prop_int_reg[0], sizeof(prop_int_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_cnt_reg[] = {
+	0x0, 0x00d00000, 0x00000010,
+	0x0, 0x00d10000, 0x00000010,
+};
+static const struct property propv_obio_cnt[] = {
+	{"name",	"counter", sizeof("counter")},
+	{"reg",		(char*)&prop_cnt_reg[0], sizeof(prop_cnt_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_eeprom_reg[] = {
+	0x0, 0x00200000, 0x00002000,
+};
+static const struct property propv_obio_eep[] = {
+	{"name",	"eeprom", sizeof("eeprom")},
+	{"reg",		(char*)&prop_eeprom_reg[0], sizeof(prop_eeprom_reg) },
+	{"model",	"mk48t08", sizeof("mk48t08")},
+	{NULL, NULL, -1}
+};
+
+static const int prop_su_reg[] = {
+	0x0, 0x003002f8, 0x00000008,
+};
+static const struct property propv_obio_su[] = {
+	{"name",	"su", sizeof("su")},
+	{"reg",		(char*)&prop_su_reg[0], sizeof(prop_su_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_zs_intr[] = { 0x26, 0x0 };
+static const int prop_zs_reg[] = {
+	0x4, 0x00000000, 0x0000000f,
+};
+static const int prop_zs_slave[] = { 0x1 };
+static const struct property propv_obio_zs[] = {
+	{"name",	"zs", sizeof("zs")},
+	{"reg",		(char*)&prop_zs_reg[0], sizeof(prop_zs_reg) },
+	{"reg",		(char*)&prop_zs_slave[0], sizeof(prop_zs_slave) },
+	{"device_type", "serial", sizeof("serial") },
+	{NULL, NULL, -1}
+};
+
+static const int prop_zs1_intr[] = { 0x26, 0x0 };
+static const int prop_zs1_reg[] = {
+	0x4, 0x00100000, 0x0000000f,
+};
+static const int prop_zs1_slave[] = { 0x0 };
+static const struct property propv_obio_zs1[] = {
+	{"name",	"zs", sizeof("zs")},
+	{"reg",		(char*)&prop_zs1_reg[0], sizeof(prop_zs1_reg) },
+	{"reg",		(char*)&prop_zs1_slave[0], sizeof(prop_zs1_slave) },
+	{"device_type", "serial", sizeof("serial") },
+	{NULL, NULL, -1}
+};
+
+static const int prop_ledma_reg[] = {
+	0x4, 0x08400010, 0x00000020,
+};
+static const int prop_ledma_burst = 0x3f;
+static const struct property propv_sbus_ledma[] = {
+	{"name",	"ledma", sizeof("ledma")},
+	{"reg",		(char*)&prop_ledma_reg[0], sizeof(prop_ledma_reg) },
+	{"burst-sizes",	(char*)&prop_ledma_burst, sizeof(int) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_le_reg[] = {
+	0x4, 0x08c00000, 0x00000004,
+};
+static const int prop_le_busmaster_regval = 0x7;
+static const int prop_le_intr[] = { 0x26, 0x0 };
+static const struct property propv_sbus_ledma_le[] = {
+	{"name",	"le", sizeof("le")},
+	{"reg",		(char*)&prop_le_reg[0], sizeof(prop_le_reg) },
+	{"busmaster-regval",	(char*)&prop_le_busmaster_regval, sizeof(int)},
+	{"intr",	(char*)&prop_le_intr[0], sizeof(prop_le_intr) },
+	{NULL, NULL, -1}
+};
+
+static const struct node nodes[] = {
+	{ &null_properties,	 1,  0 }, /* 0 = big brother of root */
+	{ propv_root,		 0,  2 }, /*  1 "/" */
+	{ propv_iommu,		 8,  3 }, /*  2 "/iommu" */
+	{ propv_sbus,		 0,  4 }, /*  3 "/iommu/sbus" */
+	{ propv_sbus_tcx,	 5,  0 }, /*  4 "/iommu/sbus/SUNW,tcx" */
+	{ propv_sbus_ledma,	 7,  6 }, /*  5 "/iommu/sbus/ledma" */
+	{ propv_sbus_ledma_le,	 0,  0 }, /*  6 "/iommu/sbus/ledma/le" */
+	{ propv_sbus_cs4231,	 0,  0 }, /*  7 "/iommu/sbus/SUNW,CS4231 */
+	{ propv_cpu,		 9,  0 }, /*  8 "/STP1012PGA" */
+	{ propv_obio,		 0, 10 }, /*  9 "/obio" */
+	{ propv_obio_int,	11,  0 }, /* 10 "/obio/interrupt" */
+	{ propv_obio_cnt,	12,  0 }, /* 11 "/obio/counter" */
+	{ propv_obio_eep,	13,  0 }, /* 12 "/obio/eeprom" */
+	{ propv_obio_su,	14,  0 }, /* 13 "/obio/su" */
+	{ propv_obio_auxio,	 0,  0 }, /* 14 "/obio/auxio" */
+	{ propv_obio_zs,	 0,  0 }, /* 14 "/obio/zs@0,0" */
+	{ propv_obio_zs1,	 0,  0 }, /* 14 "/obio/zs@0,100000" */
+};
+
+static struct linux_mlist_v0 totphys[MAX_BANKS];
+static struct linux_mlist_v0 totmap[1];
+static struct linux_mlist_v0 totavail[MAX_BANKS];
+
+static struct linux_mlist_v0 *ptphys;
+static struct linux_mlist_v0 *ptmap;
+static struct linux_mlist_v0 *ptavail;
+
+static const struct linux_nodeops nodeops0 = {
+        obp_nextnode,	/* int (*no_nextnode)(int node); */
+        obp_child,	/* int (*no_child)(int node); */
+        obp_proplen,	/* int (*no_proplen)(int node, char *name); */
+        obp_getprop,	/* int (*no_getprop)(int node,char *name,char *val); */
+        obp_setprop,	/* int (*no_setprop)(int node, char *name,
+				 char *val, int len); */
+        obp_nextprop	/* char * (*no_nextprop)(int node, char *name); */
+};
+
+static const char arg_nfsroot[] = "console=ttyS0 ip=bootp root=nfs";
+
+static const struct linux_arguments_v0 obp_arg = {
+	{ "le()", arg_nfsroot, NULL, NULL, NULL, NULL, NULL, NULL },
+	{ "" },
+	{ 'l', 'e' },  0, 0, 0, NULL,
+	NULL
+};
+static const struct linux_arguments_v0 * const obp_argp = &obp_arg;
+
+static const void * const synch_hook = NULL;
+#if 0
+static const char obp_stdin = PROMDEV_KBD;
+static const char obp_stdout = PROMDEV_SCREEN;
+#else
+static const char obp_stdin = PROMDEV_TTYA;
+static const char obp_stdout = PROMDEV_TTYA;
+#endif
+
+static int obp_nbgetchar(void);
+static int obp_nbputchar(int ch);
+static void obp_reboot(char *);
+static void obp_abort(void);
+static void obp_halt(void);
+static int obp_devopen(char *str);
+static int obp_devclose(int dev_desc);
+static int obp_rdblkdev(int dev_desc, int num_blks, int blk_st, char *buf);
+
+static void doublewalk(unsigned ptab1, unsigned va)
+{
+unsigned int proc_tablewalk(int ctx, unsigned int va);
+unsigned int mem_tablewalk(unsigned int pa, unsigned int va);
+
+	proc_tablewalk(0, va);
+	if (ptab1 != 0) mem_tablewalk(ptab1, va);
+}
+
+#ifdef ORIG
+static const struct linux_romvec romvec0 = {
+	LINUX_OPPROM_MAGIC,		/* pv_magic_cookie */
+	0,				/* pv_romvers - Format selector! */
+	77,				/* pv_plugin_revision */
+	0x10203,			/* pv_printrev */
+	{				/* pv_v0mem */
+		&ptphys,		/* v0_totphys */
+		&ptmap,			/* v0_prommap */
+		&ptavail		/* v0_available */
+	},
+        &nodeops0,			/* struct linux_nodeops *pv_nodeops; */
+        (void*)doublewalk, /* P3 */	/* char **pv_bootstr; */
+	{				/* struct linux_dev_v0_funcs pv_v0devops; */
+		&obp_devopen,		/* v0_devopen */
+		&obp_devclose,		/* v0_devclose */
+		&obp_rdblkdev,		/* v0_rdblkdev */
+		NULL,			/* v0_wrblkdev */
+		NULL,			/* v0_wrnetdev */
+		NULL,			/* v0_rdnetdev */
+		NULL,			/* v0_rdchardev */
+		NULL,			/* v0_wrchardev */
+		NULL			/* v0_seekdev */
+	},
+        &obp_stdin,			/* char *pv_stdin */
+        &obp_stdout,			/* char *pv_stdout; */
+        obp_nbgetchar,			/* int (*pv_getchar)(void); */
+        obp_nbputchar,			/* void (*pv_putchar)(int ch); */
+        obp_nbgetchar,			/* int (*pv_nbgetchar)(void); */
+        obp_nbputchar,			/* int (*pv_nbputchar)(int ch); */
+        NULL,			/* void (*pv_putstr)(char *str, int len); */
+        obp_reboot,			/* void (*pv_reboot)(char *bootstr); */
+        NULL,		/* void (*pv_printf)(__const__ char *fmt, ...); */
+        obp_abort,			/* void (*pv_abort)(void); */
+        NULL,				/* __volatile__ int *pv_ticks; */
+        obp_halt,			/* void (*pv_halt)(void); */
+        (void *)&synch_hook,		/* void (**pv_synchook)(void); */
+
+#if 0
+        /* Evaluate a forth string, not different proto for V0 and V2->up. */
+        union {
+                void (*v0_eval)(int len, char *str);
+                void (*v2_eval)(char *str);
+        } pv_fortheval;
+#endif
+	{ 0 },			/* pv_fortheval */
+
+        &obp_argp,		/* struct linux_arguments_v0 **pv_v0bootargs; */
+	NULL,			/* pv_enaddr */
+	{			/* pv_v2bootargs */
+        	NULL,		/* char **bootpath; */
+		NULL,		/* char **bootargs; */
+		NULL,		/* fd_stdin; */
+		NULL,		/* fd_stdout */
+	},
+	{			/* pv_v2devops */
+        	NULL,		/* v2_inst2pkg */
+        	NULL,		/* v2_dumb_mem_alloc */
+        	NULL,		/* v2_dumb_mem_free */
+        	NULL,		/* v2_dumb_mmap */
+        	NULL,		/* v2_dumb_munmap */
+        	NULL,		/* v2_dev_open */
+        	NULL,		/* v2_dev_close */
+        	NULL,		/* v2_dev_read */
+        	NULL,		/* v2_dev_write */
+        	NULL,		/* v2_dev_seek */
+        	NULL,		/* v2_wheee2 */
+        	NULL,		/* v2_wheee3 */
+	},
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* filler[15] */
+        NULL,			/* pv_setctxt */
+        NULL,			/* v3_cpustart */
+        NULL,			/* v3_cpustop */
+        NULL,			/* v3_cpuidle */
+        NULL			/* v3_cpuresume */
+};
+#endif
+
+static struct linux_romvec romvec0;
+
+void *
+init_openprom(int bankc, struct bank *bankv, unsigned hiphybas)
+{
+	int i;
+
+	/*
+	 * Avoid data segment allocations
+	 */
+	ptphys = totphys;
+	ptmap = totmap;
+	ptavail = totavail;
+	/*
+	 * Form memory descriptors.
+	 */
+	for (i = 0; i < bankc; i++) {
+		totphys[i].theres_more = &totphys[i+1];
+		totphys[i].start_adr = (char*) bankv[i].start;
+		totphys[i].num_bytes = bankv[i].length;
+	}
+	totphys[i-1].theres_more = 0;
+
+	/*
+	 * XXX Merged in normal PROM when full banks touch.
+	 */
+	for (i = 0; i < bankc; i++) {
+		unsigned bankbase = bankv[i].start;
+		unsigned banksize = bankv[i].length;
+		if (hiphybas > bankbase &&
+		    hiphybas < bankbase + banksize) {
+			banksize = hiphybas - bankbase;
+		}
+		totavail[i].theres_more = &totavail[i+1];
+		totavail[i].start_adr = (char*) bankbase;
+		totavail[i].num_bytes = banksize;
+	}
+	totavail[i-1].theres_more = 0;
+
+	totmap[0].theres_more = 0;
+	totmap[0].start_adr = (char*) PROLBASE;
+	totmap[0].num_bytes = PROLSIZE;
+
+	/*
+	 * idprom
+	 */
+	bcopy(idprom, obp_idprom, IDPROM_SIZE);
+
+	// Linux wants a R/W romvec table
+	romvec0.pv_magic_cookie = LINUX_OPPROM_MAGIC;
+	romvec0.pv_plugin_revision = 77;
+	romvec0.pv_printrev = 0x10203;
+	romvec0.pv_v0mem.v0_totphys = &ptphys;
+	romvec0.pv_v0mem.v0_prommap = &ptmap;
+	romvec0.pv_v0mem.v0_available = &ptavail;
+	romvec0.pv_nodeops = &nodeops0;
+	romvec0.pv_bootstr = (void *)doublewalk;
+	romvec0.pv_stdin = &obp_stdin;
+	romvec0.pv_stdout = &obp_stdout;
+	romvec0.pv_getchar = obp_nbgetchar;
+	romvec0.pv_putchar = obp_nbputchar;
+	romvec0.pv_nbgetchar = obp_nbgetchar;
+	romvec0.pv_nbputchar = obp_nbputchar;
+	romvec0.pv_reboot = obp_reboot;
+	romvec0.pv_abort = obp_abort;
+	romvec0.pv_halt = obp_halt;
+	romvec0.pv_synchook = &synch_hook;
+	romvec0.pv_v0bootargs = &obp_argp;
+	return &romvec0;
+}
+
+static const struct property *find_property(int node,char *name)
+{
+	const struct property *prop = &nodes[node].properties[0];
+	while (prop && prop->name) {
+		if (bcmp(prop->name, name, 128) == 0) return prop;
+		prop++;
+	}
+	return NULL;
+}
+
+static int obp_nextnode(int node)
+{
+	return nodes[node].sibling;
+}
+
+static int obp_child(int node)
+{
+	return nodes[node].child;
+}
+
+static int obp_proplen(int node, char *name)
+{
+	const struct property *prop = find_property(node,name);
+	if (prop) return prop->length;
+	return -1;
+}
+
+static int obp_getprop(int node, char *name, char *value)
+{
+	const struct property *prop;
+
+	prop = find_property(node,name);
+	if (prop) {
+		memcpy(value,prop->value,prop->length);
+		//printk("obp_getprop '%s'= %s\n", name, value);
+		return prop->length;
+	}
+        //printk("obp_getprop: not found\n");
+	return -1;
+}
+
+static int obp_setprop(int node, char *name, char *value, int len)
+{
+	return -1;
+}
+
+static const char *obp_nextprop(int node,char *name)
+{
+	const struct property *prop = find_property(node,name);
+	if (prop) return prop[1].name;
+	return NULL;
+}
+
+#if 0
+static unsigned char calc_idprom_cksum(struct idprom *idprom)
+{
+        unsigned char cksum, i, *ptr = (unsigned char *)idprom;
+
+        for (i = cksum = 0; i <= 0x0E; i++)
+                cksum ^= *ptr++;
+
+        return cksum;
+}
+#endif
+
+static int obp_nbgetchar(void) {
+	return -1;
+}
+
+static int obp_nbputchar(int ch) {
+	extern struct vconterm dp0;
+	char buf = ch;
+
+	/* We do not use printk() in order to reduce stack depth. */
+	vcon_write(&dp0, &buf, 1);
+	return 0;
+}
+
+static void obp_reboot(char *str) {
+	printk("rebooting (%s): not implemented, freezing\n", str);
+	for (;;) {}
+}
+
+static void obp_abort() {
+	printk("abort, freezing\n");
+	for (;;) {}
+}
+
+static void obp_halt() {
+	printk("halt, freezing\n");
+	for (;;) {}
+}
+
+static int obp_devopen(char *str) {
+        //printk("open %s\n", str);
+	return 0;
+}
+
+static int obp_devclose(int dev_desc) {
+        //printk("close %d\n", dev_desc);
+	return 0;
+}
+
+static int obp_rdblkdev(int dev_desc, int num_blks, int blk_st, char *buf) {
+    //printk("rdblkdev: fd %d, num_blks %d, blk_st %d, buf 0x%x\n", dev_desc, num_blks, blk_st, buf);
+    //buf[8] = 'L';
+    return num_blks;
+}
diff -ruN proll_18.orig/src/arp.c proll-patch4/src/arp.c
--- proll_18.orig/src/arp.c	2001-12-24 05:12:31.000000000 +0000
+++ proll-patch4/src/arp.c	2004-11-13 15:50:49.000000000 +0000
@@ -45,7 +45,7 @@
 #endif
 static struct arp_cache arp_list[ARPNUM];	/* ARP address cache	*/
 static int next_arp;				/* next table entry	*/
-static t_ipaddr def_gw = IP_ANY;		/* default routing	*/
+static t_ipaddr def_gw;				/* default routing	*/
 
 
 
@@ -144,7 +144,7 @@
  * 
  * Resolve IP address and return pointer to hardware address.
  */
-unsigned char *ip_resolve(ip)
+const unsigned char *ip_resolve(ip)
 t_ipaddr ip;
 {
   int i;
@@ -230,14 +230,11 @@
  */
 int init_arp()
 {
-  /* Set name of module for error messages */
-  net_module_name = "arp";
-
 #ifndef NOARP
   /* Register ARP packet type and set send buffer pointer */
   if ((arpbuf = (struct arphdr *)reg_type(htons(ETH_P_ARP), arp_recv)) == NULL)
 	return(FALSE);
 #endif
-
+  def_gw = IP_ANY;
   return(TRUE);
 }
diff -ruN proll_18.orig/src/arp.h proll-patch4/src/arp.h
--- proll_18.orig/src/arp.h	1999-03-18 03:39:43.000000000 +0000
+++ proll-patch4/src/arp.h	2004-11-13 15:50:49.000000000 +0000
@@ -104,7 +104,7 @@
 extern int init_arp __P((void));
 
 /* Resolve IP address and return pointer to hardware address */
-extern unsigned char *ip_resolve __P((t_ipaddr ip));
+extern const unsigned char *ip_resolve __P((t_ipaddr ip));
 
 /* Add a new antry to the ARP cache */
 extern void addcache __P((unsigned char *ha, t_ipaddr ip));
diff -ruN proll_18.orig/src/hconsole.c proll-patch4/src/hconsole.c
--- proll_18.orig/src/hconsole.c	2002-07-23 05:52:48.000000000 +0000
+++ proll-patch4/src/hconsole.c	2004-11-13 15:50:49.000000000 +0000
@@ -42,7 +42,11 @@
  	 * No probing sequence or argument passing, hardcode everything. XXX
 	 */
 	raster8_cons_a(q, 768, 1024, (char *)a0);
+#if 1
 	raster_cons_2(r, q, 768-(24*11)-1, 1024-(8*80)-1, (24*11), (8*80));
+#else
+	raster_cons_2(r, q, 0, 0, 768, 1024);
+#endif
 	t->r_ = r;
 	t->r0_ = q;
 	t->f_ = &f_master;
diff -ruN proll_18.orig/src/lat7_2.bm proll-patch4/src/lat7_2.bm
--- proll_18.orig/src/lat7_2.bm	1999-02-27 05:48:54.000000000 +0000
+++ proll-patch4/src/lat7_2.bm	2004-11-13 15:50:49.000000000 +0000
@@ -1,6 +1,6 @@
 #define lat7_2_width 128
 #define lat7_2_height 88
-static unsigned char lat7_2_bits[] = {
+static unsigned const char lat7_2_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x12, 0x1e, 0x0c, 0x02, 0x70, 0x18,
    0x22, 0x22, 0x18, 0x00, 0x00, 0x18, 0x18, 0xff, 0x18, 0x00, 0x12, 0x02,
diff -ruN proll_18.orig/src/lat7_2_swapped.bm proll-patch4/src/lat7_2_swapped.bm
--- proll_18.orig/src/lat7_2_swapped.bm	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch4/src/lat7_2_swapped.bm	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,121 @@
+#define lat7_2_width 128
+#define lat7_2_height 88
+static unsigned const char lat7_2_bits[] = {
+   0x00, 0x00, 0x18, 0x3c, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x55, 0x00, 0x2a, 0x00, 0x55, 0x00, 0x2a, 0x00, 0x55, 0x00, 0x00, 0x48, 
+   0x48, 0x78, 0x48, 0x5f, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x78, 0x40, 
+   0x70, 0x40, 0x4f, 0x08, 0x0e, 0x08, 0x08, 0x00, 0x00, 0x30, 0x40, 0x40, 
+   0x40, 0x3e, 0x09, 0x0e, 0x0a, 0x09, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 
+   0x7f, 0x08, 0x0e, 0x08, 0x08, 0x00, 0x00, 0x0e, 0x0a, 0x0e, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 
+   0x7e, 0x00, 0x00, 0x00, 0x00, 0x44, 0x64, 0x54, 0x4c, 0x54, 0x10, 0x10, 
+   0x10, 0x1f, 0x00, 0x00, 0x44, 0x44, 0x44, 0x28, 0x1f, 0x04, 0x04, 0x04, 
+   0x04, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
+   0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
+   0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0xff, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0xff, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 
+   0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 
+   0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x00, 
+   0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
+   0x06, 0x0c, 0x18, 0x30, 0x18, 0x6c, 0x36, 0x18, 0x0c, 0x00, 0x00, 0x60, 
+   0x30, 0x18, 0x0c, 0x18, 0x36, 0x6c, 0x18, 0x30, 0x00, 0x00, 0x7f, 0x36, 
+   0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x7e, 
+   0x18, 0x7e, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x78, 
+   0x30, 0x72, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
+   0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 
+   0x00, 0x00, 0x00, 0x66, 0x66, 0x22, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x36, 0x7f, 0x36, 0x36, 0x36, 0x7f, 0x36, 0x00, 0x00, 0x00, 
+   0x00, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x72, 0x56, 0x6c, 0x18, 0x36, 0x6a, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x18, 
+   0x24, 0x28, 0x30, 0x4a, 0x44, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x18, 
+   0x18, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x18, 
+   0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0x7e, 0x3c, 
+   0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00, 0x00, 0x00, 
+   0x00, 0x3c, 0x46, 0x4e, 0x5a, 0x72, 0x62, 0x3c, 0x00, 0x00, 0x00, 0x00, 
+   0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3c, 
+   0x66, 0x06, 0x0c, 0x18, 0x32, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 
+   0x66, 0x7e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x60, 0x7c, 0x66, 
+   0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x60, 0x7c, 0x66, 0x66, 
+   0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x46, 0x06, 0x0c, 0x18, 0x30, 
+   0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 
+   0x00, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
+   0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x06, 0x0c, 0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x5e, 
+   0x56, 0x5e, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x66, 
+   0x7e, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x66, 
+   0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 
+   0x00, 0x00, 0x00, 0x00, 0x7e, 0x62, 0x60, 0x78, 0x60, 0x62, 0x7e, 0x00, 
+   0x00, 0x00, 0x00, 0x7e, 0x62, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00, 0x00, 
+   0x00, 0x00, 0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 
+   0x00, 0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x7e, 
+   0x46, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6c, 
+   0x78, 0x70, 0x78, 0x6c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 
+   0x60, 0x60, 0x62, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x41, 0x63, 0x77, 0x7f, 
+   0x6b, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x76, 0x7e, 0x6e, 
+   0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x6e, 0x3c, 0x02, 
+   0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x00, 0x00, 
+   0x00, 0x00, 0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 
+   0x00, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
+   0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x66, 
+   0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 
+   0x63, 0x6b, 0x6b, 0x7f, 0x36, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3c, 
+   0x18, 0x3c, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 
+   0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x46, 0x0c, 0x18, 0x30, 
+   0x62, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 
+   0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 
+   0x00, 0x08, 0x10, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x3c, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x60, 
+   0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x66, 0x60, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 
+   0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x7e, 0x60, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x78, 
+   0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 0x66, 0x66, 
+   0x3e, 0x06, 0x3c, 0x00, 0x00, 0x60, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x1c, 0x00, 
+   0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 
+   0x00, 0x00, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x7c, 0x66, 0x00, 0x00, 0x00, 
+   0x00, 0x60, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x76, 0x7f, 0x6b, 0x6b, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x6c, 0x76, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 
+   0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 
+   0x66, 0x66, 0x3e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x72, 0x60, 
+   0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x60, 0x3c, 0x06, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x78, 0x30, 0x30, 0x36, 0x1c, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3a, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x63, 0x6b, 0x6b, 0x6b, 0x36, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c, 0x00, 0x00, 0x00, 
+   0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 
+   0x18, 0x30, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 
+   0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x0c, 
+   0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x42, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00};
diff -ruN proll_18.orig/src/le.c proll-patch4/src/le.c
--- proll_18.orig/src/le.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch4/src/le.c	2004-11-13 15:50:49.000000000 +0000
@@ -185,8 +185,6 @@
 	unsigned short rap;			/* register address port */
 };
 
-int sparc_lance_debug = 2;
-
 /* The Lance uses 24 bit addresses */
 /* On the Sun4c the DVMA will provide the remaining bytes for us */
 /* On the Sun4m we have to instruct the ledma to provide them    */
diff -ruN proll_18.orig/src/netinit.c proll-patch4/src/netinit.c
--- proll_18.orig/src/netinit.c	2002-09-13 21:53:33.000000000 +0000
+++ proll-patch4/src/netinit.c	2004-11-13 15:50:49.000000000 +0000
@@ -49,13 +49,20 @@
 unsigned char     myhwaddr[ETH_ALEN];		/* my own hardware addr	*/
          t_ipaddr myipaddr;			/* my own IP address	*/
          t_ipaddr mynetmask;			/* my own netmask	*/
-         char    *net_module_name;		/* name of init module	*/
          t_ipaddr servaddr;			/* IP of RARP&TFTP server */
 
 /* Broadcast hardware address */
-unsigned char bcasthw[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+const unsigned char bcasthw[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 
+unsigned int seed;
+
+/* This is taken from x86 to be used in network kernel. Returns 15 bits. */
+short int random()
+{
+	seed = (seed + 23968)*0x015A4E35 >> 1;
+	return seed & 0x7FFF;
+}
 
 /*
  **************************************************************************
@@ -104,10 +111,17 @@
  */
 void init_net()
 {
+  /* Avoid data segment allocations */
+  seed = 151;
+
   /* Initialize the different network layer modules */
   init_packet();
-  if (!init_arp() || !init_udp()) {
-	printf("\nERROR: init_%s\n", net_module_name);
+  if (!init_arp()) {
+	printf("\nERROR: init_arp\n");
+	fatal();
+  }
+  if (!init_udp()) {
+	printf("\nERROR: init_udp\n");
 	fatal();
   }
 }
diff -ruN proll_18.orig/src/netpriv.h proll-patch4/src/netpriv.h
--- proll_18.orig/src/netpriv.h	1999-04-27 05:39:37.000000000 +0000
+++ proll-patch4/src/netpriv.h	2004-11-13 15:50:49.000000000 +0000
@@ -130,10 +130,9 @@
  *
  */
 extern unsigned char myhwaddr[ETH_ALEN]; /* my own hardware address	*/
-extern unsigned char bcasthw[ETH_ALEN];  /* broadcast hardware addr	*/
+extern const unsigned char bcasthw[ETH_ALEN];  /* broadcast hardware addr	*/
 extern t_ipaddr      myipaddr;           /* my own IP address		*/
 extern t_ipaddr      mynetmask;		 /* netmask for my network	*/
-extern char         *net_module_name;	 /* initialized module's name	*/
 extern t_ipaddr      servaddr;           /* server IP address		*/
 
 
@@ -150,7 +149,7 @@
 extern unsigned char *reg_type __P((int typeval, int (* receive)()));
 
 /* Write a packet to the network */
-extern int write_packet __P((int bufsize, int typeval, unsigned char *addr));
+extern int write_packet __P((int bufsize, int typeval, const unsigned char *addr));
 
 /* Empty read buffer */
 extern void empty_buf __P((void));
diff -ruN proll_18.orig/src/openprom.h proll-patch4/src/openprom.h
--- proll_18.orig/src/openprom.h	2002-07-14 02:26:30.000000000 +0000
+++ proll-patch4/src/openprom.h	2004-11-13 15:50:49.000000000 +0000
@@ -54,20 +54,20 @@
 };
 
 struct linux_mem_v0 {
-	struct linux_mlist_v0 **v0_totphys;
-	struct linux_mlist_v0 **v0_prommap;
-	struct linux_mlist_v0 **v0_available; /* What we can use */
+	struct linux_mlist_v0 * const *v0_totphys;
+	struct linux_mlist_v0 * const *v0_prommap;
+	struct linux_mlist_v0 * const *v0_available; /* What we can use */
 };
 
 /* Arguments sent to the kernel from the boot prompt. */
 struct linux_arguments_v0 {
-	char *argv[8];
+	const char *argv[8];
 	char args[100];
 	char boot_dev[2];
 	int boot_dev_ctrl;
 	int boot_dev_unit;
 	int dev_partition;
-	char *kernel_file_name;
+	const char *kernel_file_name;
 	void *aieee1;           /* XXX */
 };
 
@@ -91,13 +91,13 @@
 	struct linux_mem_v0 pv_v0mem;
 
 	/* Node operations. */
-	struct linux_nodeops *pv_nodeops;
+	const struct linux_nodeops *pv_nodeops;
 
 	char **pv_bootstr;
 	struct linux_dev_v0_funcs pv_v0devops;
 
-	char *pv_stdin;
-	char *pv_stdout;
+	const char *pv_stdin;
+	const char *pv_stdout;
 #define	PROMDEV_KBD	0		/* input from keyboard */
 #define	PROMDEV_SCREEN	0		/* output to screen */
 #define	PROMDEV_TTYA	1		/* in/out to ttya */
@@ -127,7 +127,7 @@
 		void (*v2_eval)(char *str);
 	} pv_fortheval;
 
-	struct linux_arguments_v0 **pv_v0bootargs;
+	const struct linux_arguments_v0 * const *pv_v0bootargs;
 
 	/* Get ether address. */
 	unsigned int (*pv_enaddr)(int d, char *enaddr);
@@ -175,7 +175,7 @@
 	int (*no_proplen)(int node, char *name);
 	int (*no_getprop)(int node, char *name, char *val);
 	int (*no_setprop)(int node, char *name, char *val, int len);
-	char * (*no_nextprop)(int node, char *name);
+	const char * (*no_nextprop)(int node, char *name);
 };
 
 /* More fun PROM structures for device probing. */
diff -ruN proll_18.orig/src/packet.c proll-patch4/src/packet.c
--- proll_18.orig/src/packet.c	2000-02-11 04:56:45.000000000 +0000
+++ proll-patch4/src/packet.c	2004-11-13 15:50:49.000000000 +0000
@@ -41,7 +41,7 @@
 	int aligner;
 } wbuf;
 static struct sk_buff *rskb;
-static int nqskb = 0;
+static int nqskb;
 
 
 void init_packet()
@@ -62,6 +62,8 @@
 	for (i = 0; i < MAXSKBS; i++) {
 		skev[i].skb.allocn = i;
 	}
+
+	nqskb = 0;
 }
 
 unsigned char *reg_type(int ptype, int (*func)())
@@ -81,7 +83,7 @@
 	return wbuf.s;
 }
 
-int write_packet(int leng, int type, unsigned char *dst)
+int write_packet(int leng, int type, const unsigned char *dst)
 {
 	struct sk_buff *skb;
 	unsigned char *s;
diff -ruN proll_18.orig/src/printf.c proll-patch4/src/printf.c
--- proll_18.orig/src/printf.c	1999-03-19 07:03:59.000000000 +0000
+++ proll-patch4/src/printf.c	2004-11-13 15:50:49.000000000 +0000
@@ -19,7 +19,7 @@
 static void printn(struct prf_fp *, unsigned long, unsigned int);
 static void putchar(char, struct prf_fp *);
 
-static char hextab[] = "0123456789ABCDEF";
+static const char hextab[] = "0123456789ABCDEF";
 
 /*
  * Scaled down version of C Library printf.
@@ -41,7 +41,7 @@
 void
 prf(struct prf_fp *filog, char *fmt, va_list adx)
 {
-        register c;
+        register int c;
         char *s;
 
 	for(;;) {
@@ -60,7 +60,7 @@
                 	putchar(va_arg(adx,unsigned), filog);
         	} else if(c == 's') {
                 	s = va_arg(adx,char*);
-               		while(c = *s++)
+               		while((c = *s++))
                         	putchar(c,filog);
        		} else if (c == 'l' || c == 'O') {
         	        printn(filog, (long)va_arg(adx,long), c=='l'?10:8);
diff -ruN proll_18.orig/src/rconsole.c proll-patch4/src/rconsole.c
--- proll_18.orig/src/rconsole.c	1999-01-16 07:16:55.000000000 +0000
+++ proll-patch4/src/rconsole.c	2004-11-13 15:50:49.000000000 +0000
@@ -28,12 +28,18 @@
  * move to California. Only plain lat7 survived. 
  * I recreated lat7-1 changes in lat7-2.  --zaitcev
  */
+#ifdef ORIG
 #include "lat7_2.bm"	/* lat7_1.bm */
+#else
+#include "lat7_2_swapped.bm"	/* lat7_1.bm */
+#endif
 #define LAT7_NCHARS  128
 #define LAT7_HEIGHT   11
 #define LAT7_WIDTH     8
 
+#ifdef ORIG
 static Rf_scan lat7_body[ LAT7_NCHARS*LAT7_HEIGHT ];
+#endif
 
 #if 1
 /*
@@ -94,6 +100,7 @@
 
 #endif
 
+#ifdef ORIG
 static inline int swapbits(int w0)
 {
   int w1 = 0;
@@ -105,13 +112,16 @@
   }
   return w1;
 }
+#endif
 
 void font_cons_7(struct rfont *p)
 {
+#ifdef ORIG
   int x;
   int col = 0;
   int row = 0;
   int erow = 0;
+
   for (x = 0; x < LAT7_NCHARS*LAT7_HEIGHT; x++ ) {
     lat7_body[ (erow * lat7_2_width/8 + col) * LAT7_HEIGHT + row ] =
                                             swapbits(lat7_2_bits[x]) & 0xFF;
@@ -124,6 +134,9 @@
     }
   }
   p->body_ = lat7_body;
+#else
+  p->body_ = lat7_2_bits;
+#endif
   p->nchars_ = LAT7_NCHARS;
   p->width_ = LAT7_WIDTH;
   p->height_ = LAT7_HEIGHT;
diff -ruN proll_18.orig/src/rconsole.h proll-patch4/src/rconsole.h
--- proll_18.orig/src/rconsole.h	1999-01-16 05:00:59.000000000 +0000
+++ proll-patch4/src/rconsole.h	2004-11-13 15:50:49.000000000 +0000
@@ -13,10 +13,10 @@
  */
 
 #define RF_MAXWIDTH  16
-typedef unsigned short Rf_scan;        /*  __w16 to be used */
+typedef unsigned char Rf_scan;        /*  __w16 to be used */
 
 struct rfont {
-  Rf_scan *body_;
+  const Rf_scan *body_;
   int nchars_;                 /* 128 for ASCII ...  65536 for Unicode   */
   int width_;                  /* [Pixels]. Maximum size is 16.          */
   int height_;                 /* [Pixels == scan lines].                */
diff -ruN proll_18.orig/src/romlib.h proll-patch4/src/romlib.h
--- proll_18.orig/src/romlib.h	1999-04-20 04:26:45.000000000 +0000
+++ proll-patch4/src/romlib.h	2004-11-13 15:50:49.000000000 +0000
@@ -73,12 +73,12 @@
 #define memcpy(dst, src, len)	bcopy(src, dst, len)
 #define memcmp(x1, x2, len)	bcmp(x1, x2, len)
 #define memset(p, len, zero)	bzero(p, len)
-extern void bcopy(void *b1, void *b2, int length);
-extern int  bcmp(void *b1, void *b2, int length);
+extern void bcopy(const void *b1, void *b2, int length);
+extern int  bcmp(const void *b1, const void *b2, int length);
 extern void bzero(void *b, int c);
 /* gcc complains about "conflicting types for builtin function strlen". */
 #define strlen(s)		ssize(s)
-extern int ssize(char *s);
+extern int ssize(const char *s);
 
 
 /*
diff -ruN proll_18.orig/src/sched_4m.c proll-patch4/src/sched_4m.c
--- proll_18.orig/src/sched_4m.c	1999-04-27 05:48:51.000000000 +0000
+++ proll-patch4/src/sched_4m.c	2004-11-13 15:50:49.000000000 +0000
@@ -108,7 +108,7 @@
 static int set_bolt;			/* Tick counter limit */
 static struct handsc hndv[16];
 
-static unsigned int intr_to_mask[16] = {
+static unsigned const int intr_to_mask[16] = {
 	0,	0,	0,	0,	0,	0, SUN4M_INT_ETHERNET,	0,
 	0,	0,	0,	0,	0,	0,	0,	0,
 };
diff -ruN proll_18.orig/src/swap.c proll-patch4/src/swap.c
--- proll_18.orig/src/swap.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch4/src/swap.c	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,21 @@
+// Convert the lat7 font so that no conversion is needed at runtime.
+#define ORIG
+#include "rconsole.c"
+
+#include <stdio.h>
+
+int main()
+{
+    struct rfont p;
+    int i;
+
+    font_cons_7(&p);
+
+    printf("   ");
+    for (i = 0; i < LAT7_NCHARS*LAT7_HEIGHT; i++) {
+	printf("0x%02x, ", p.body_[i]);
+	if ((i % 12) == 11)
+	    printf("\n   ");
+    }
+    printf("\n");
+}
diff -ruN proll_18.orig/src/system.c proll-patch4/src/system.c
--- proll_18.orig/src/system.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch4/src/system.c	2004-11-13 15:50:49.000000000 +0000
@@ -298,8 +298,8 @@
 	}
 
 	/* We need to start from LOADBASE, but kernel wants PAGE_SIZE. */
-	pa = PAGE_SIZE;
-	for (va = PAGE_SIZE; va < LOWMEMSZ; va += PAGE_SIZE) {
+	pa = 0;
+	for (va = 0; va < LOWMEMSZ; va += PAGE_SIZE) {
 		map_page(l1, va, pa, 0, highbase);
 		pa += PAGE_SIZE;
 	}
@@ -518,12 +518,12 @@
 	while (len--) *((char *)s)++ = 0;
 }
 
-void bcopy(void *f, void *t, int len) {
+void bcopy(const void *f, void *t, int len) {
 	while (len--) *((char *)t)++ = *((char *)f)++;
 }
 
 /* Comparison is 7-bit */
-int bcmp(void *s1, void *s2, int len)
+int bcmp(const void *s1, const void *s2, int len)
 {
 	int i;
 	char ch;
@@ -538,8 +538,8 @@
 	return 0;
 }
 
-int strlen(char *s) {
-	char *p;
+int strlen(const char *s) {
+	const char *p;
 	for (p = s; *p != 0; p++) { }
 	return p - s;
 }
@@ -560,14 +560,6 @@
 	va_end(x1);
 }
 
-/* This is taken from x86 to be used in network kernel. Returns 15 bits. */
-short int random()
-{
-	static unsigned int seed = 151;
-	seed = (seed + 23968)*0x015A4E35 >> 1;
-	return seed & 0x7FFF;
-}
-
 void fatal()
 {
 	printk("fatal.");
diff -ruN proll_18.orig/src/system.h proll-patch4/src/system.h
--- proll_18.orig/src/system.h	2002-09-13 21:53:32.000000000 +0000
+++ proll-patch4/src/system.h	2004-11-13 15:50:49.000000000 +0000
@@ -16,7 +16,7 @@
 #define IOMAPSIZE (1*1024*1024) /* 1 Meg maximum: we do not map framebuffer. */
 #define NCTX_SWIFT  0x100
 
-#define MAX_BANKS      3		/* Allocation for all machines */
+#define MAX_BANKS      8		/* Allocation for all machines */
 
 #ifndef __ASSEMBLY__
 struct bank {
diff -ruN proll_18.orig/src/udp.c proll-patch4/src/udp.c
--- proll_18.orig/src/udp.c	2001-12-24 05:12:53.000000000 +0000
+++ proll-patch4/src/udp.c	2004-11-13 15:50:49.000000000 +0000
@@ -81,7 +81,7 @@
 int      source;
 int      dest;
 {
-  register unsigned char *addr;
+  const register unsigned char *addr;
 
   /* Set global variables */
   usource = source;
@@ -299,9 +299,6 @@
  */
 int init_udp()
 {
-  /* Set module name for error handling */
-  net_module_name = "udp";
-
   /* Register IP packet type and set write buffer pointer */
   if ((writebuf = reg_type(htons(ETH_P_IP), ip_recv)) == NULL)
 	return(FALSE);
